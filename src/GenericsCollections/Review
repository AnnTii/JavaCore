Что такое дженерики? Какую проблему они решают?
Дженерики (обобщения) - это параметризованные типы.
С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. Дженерики добавили в язык безопасность типов.
До появления дженериков мы использовали коллекцию для хранения объектов любого типа.
Если не использовать дженерики, все объекты принимаются как Object. Поэтому там, где нам нужен конкретный тип, а не Object, нам нужно делать явное приведение типа данных каждый раз, когда возвращаем элементы.
Другой пример - коллекция принимает список объектов, этот список хранит не только String, но и Integer. Компилятор не увидит ничего плохого. Мы получим ошибку
Так же если не делать проверку (instanceof) на принадлежность к классу, то иногда можно получить ClassCastException –аварийное завершение программы.
Преимущества кода с использованием Generic по сравнению с кодом без Generic
Более строгая проверка типов во время компиляции.
Отсутствие необходимости приведения типов.
Возможность реализации общих алгоритмов, не завязанных на конкретных типах.
Что можно поставить в дженерики, что нельзя? Что можно типизировать? Что нельзя параметризировать?
Можно типизировать только ссылочные типы.
Нельзя типизировать примитивные типы.
Невозможно объявить статические поля, типы которых являются параметрами типа.
Невозможно использовать приведение или instanceof с параметризованными типами.
Почему последняя строчка не скомпилируется?
List<ArrayList> arrayLists = new ArrayList<ArrayList>();
ArrayList<List> arrayList = new ArrayList<ArrayList>();
Слева и справа разные типы, у дженериков нет наследования в данном виде.
Wildcard
Wildcard — это дженерик вида <?>, что означает, что тип может быть чем угодно.
Используется, например, в коллекциях, где для всех коллекций базовым типом является Сollection<?>.
Благодаря Wildcard можно сделать универсальный метод (или переменную), работающий с разными типами данных.
Wildcards играют важную роль в системе типов. Они позволяют задать границы для семейства типов, определенных каким-нибудь generic-классом.
Принцип PECS
Коллекции с wildcards и ключевым словом extends — это producers (производители, генераторы), они лишь предоставляют данные(сами ничего не принимают).
Если аргумент используется как поставщик, то есть нужно что-то взять из объекта, то используется <? extends SomeClass>.
Коллекции с wildcards и ключевым словом super — это consumers (потребители),
они принимают данные, но не отдают их.
Если аргумент используется как потребитель, то есть нужно что-то положить в объект, то используется <? super SomeClass>.
В коллекцию с extends нельзя добавлять, а из коллекции с super нельзя читать.
Исключением является возможность записать null для extends и прочитать Object для super.
Что такое даймонд оператор?
Основная цель diamoind <> оператора упростить использование универсальных шаблонов при создании объекта . Это позволяет избежать непроверенных предупреждений в программе и делает программу более читаемой.
Что такое raw type? К чему приводит использование raw type?
Raw Types (сырые типы) – Это имя универсального класса или интерфейса без каких-либо аргументов типа. их нужно избегать. Например, использовать List вместо List<String>
Пример сырого типа List list = new ArrayList<>;
Они нужны только для поддержки обратной совместимости кода, «сырые типы» являются не «типобезопасными». Если вы не указали тип, например, своей коллекции, то туда можно запихнуть другой объект любого типа.
Отличие raw type от даймонд оператора?
Сырые типы — это типы без указания "уточненения" в фигурных скобках.
Diamond синтаксис связан с понятием Типизированные типы — наоборот, с указанием "уточнения". Компилятор, видя справа <> смотрит на левую часть, где расположено объявление типа переменной, в которую присваивается значение. И по этой части понимает, каким типом типизируется значение справа.
Всегда использовать diamond синтаксис, если мы используем типизированные типы. В противном случае мы рискуем пропустить, где у нас используется raw type.
Стирание типов?
Стирание типов относится к процессу загрузки, с помощью которого явные аннотации типов удаляются из программы перед её выполнением во время выполнения.
Соответственно стирание типа происходит во время компиляции.
Весь написанный код превратится в байт-код, в нём не будет информации о типах-параметрах.
Это делается таким образом из-за проблем совместимости: целью разработчиков языка было обеспечение полной совместимости исходного кода и полной совместимости байтового кода между версиями платформы. Если бы он был реализован по-другому, нам пришлось бы перекомпилировать устаревшие приложения при переходе на более новые версии платформы.
Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?
Стирание типов в runtime. Дженерики позволяют проверять типы во время компиляции.
Во время исполнения программы информации о типах не доступна.
После компиляции какая-либо информация о дженериках стирается.
Стирание типов и дженерики сделаны так, чтобы обеспечить обратную совместимость со старыми версиями JDK, но при этом дать возможность помогать компилятору с определением типа в новых версиях Java.
Если поле типизировано дженериком, то как в байт коде будет представлен этот тип?
Будет представлен как экземпляр Object.
В чем отличие в записях в параметре метода: (Collection<?> collection) и (Collection <? extends T> collection)?
В первом случае мы можем подставить абсолютно любой тип, а во втором только T и его наследников.
Параметр vs Аргумент (в дженериках)?
Параметр (type parameter).
Используются при объявлении дженерик-типов.
Например, для Box <T>. T — это параметр типа.
Аргумент (type argument).
Тип объекта, который может использоваться вместо параметра типа.
Например, для Box <Paper>. Paper — это аргумент типа.
Параметризированные классы?
Обобщенный класс может быть объявлен с любым количеством параметров типа.
Java не создает разные версии класса или любого другого параметризованного класса.
Имеется только одна версия класса, которая существует в прикладной программе.
Параметризованные классы могут быть частью иерархии классов так же, как и любые другие не параметризованные классы.
То есть параметризованный класс может выступать в качестве суперкласса или подкласса.
Ключевое отличие между параметризованными и не параметризованными иерархиями состоит в том, что в параметризованной иерархии любые аргументы типов, необходимые параметризованному суперклассу, всеми подклассами должны передаваться по иерархии вверх.
Параметризированные интерфейсы?
Параметризованные интерфейсы специфицируются так же, как и обобщенные классы.
Параметризованные методы и конструкторы.
В методах параметризованного класса можно использовать параметр типа, а следовательно, они становятся параметризованными относительно параметра типа.
Можно объявить параметризованный метод, в котором непосредственно используется один или несколько параметров типа. Более того, можно объявить параметризованный метод, входящий в не параметризованный класс.
Конструкторы также могут быть обобщенными, даже если их классы таковыми не являются.
Параметризация статических методов.
Нельзя создавать обобщенные статические переменные и методы.
Но объявить статические обобщенные методы со своими параметрами типа всё же можно.
Если метод статический, то унаследовать параметр типа от класса он не может. Это вызвано тем, что параметр типа привязывается к конкретному объекту при его создании, а статический метод не привязан к конкретному объекту, он привязан к классу в целом. В случае статического метода параметр типа нужно указывать непосредственно перед объявлением метода.
public static <V> void getOb(V v).
Ограничения присущие обобщениям.
Нельзя создавать экземпляр по параметру типа. Ни обычный объект, ни массив.
Нельзя создать массив специфических для типа обобщенных ссылок.
Нельзя создавать обобщенные статические переменные и методы. Но объявить статические обобщенные методы со своими параметрами типа все же можно.



Что такое коллекция. Иерархия коллекций.
Коллекция — это структура данных, позволяющая хранить набор каких-либо объектов. Объектами в наборе могут быть числа, строки, объекты пользовательских классов и т.п. Коллекция позволяет хранить их в одном массиве и обращаться к ним. Коллекция может автоматически расширяться.
Обеспечивают удобство при работе с информацией, удобная запись, сортировка и хранение данных.


Какие структуры данных вы знаете?
Простыми словами, структура данных – это контейнер, который хранит информацию в определенном виде. Из-за такой «компоновки» она может быть эффективной в одних операциях и неэффективной в других. Цель разработчика – выбрать из существующих структур оптимальный для конкретной задачи вариант.
Массив (Array) - это структура данных, в которой хранятся элементы одного типа.
Стек (Stack) - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO («последним пришёл — первым вышел»).
Очередь (Queue) - это структура данных, добавление и удаление элементов, первым из очереди удаляется элемент, который был помещен туда первым, то есть в очереди реализуется принцип FIFO («первым вошел — первым вышел»).
Связный список (Linked List) - это структура данных, в которой элементы линейно упорядочены, но порядок определяется не номерами элементов (как в массивах), а указателями, входящих в состав элементов списка и указывают на следующий элемент. У списка должна быть «голова» (первый элемент) и «хвост» (последний элемент).
Дерево (Tree) - структура данных, в которой каждый узел (родительский) имеет не более двух потомков (правый и левый наследник). На практике обычно используются два вида двоичных деревьев — двоичное дерево поиска и пирамида (куча).
Граф (Graph) - совокупность непустого множества вершин и наборов пар вершин (связей между вершинами).
Префиксное дерево (Trie) - абстрактный тип данных, структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки. В отличие от бинарных деревьев, в листьях дерева не хранится ключ.
Хэш-Таблица (Hash Table) - это структура данных для хранения пар ключей и их значений. По сути она представляет собой массив, где местоположение элемента зависит от значения самого элемента. Связь между значением элемента и его позицией в хеш-таблице задает хеш-функция.
В чем разница между классами java.util.Collection и java.util.Collections?
Collections - набор статических методов для работы с коллекциями.
Collection - один из основных интерфейсов Java Collections Framework.
Отличие коллекции от массива?
Массивы - это простые конструкции фиксированного размера, и поэтому они могут хранить только заданное количество элементов. Массивы встроены в ядро языка Java, и используемый при работе с ними синтаксис Java очень прост и понятен. Например, чтобы получить элемент массива с номером n, вам нужно вызвать функцию array[n].
Коллекции - это более сложный, но в то же время более гибкий тип данных. Прежде всего, размер коллекции можно изменять: мы можем добавлять в коллекцию любое количество элементов. Коллекции автоматически обрабатывают удаление элемента из любой позиции.
На чём основаны основные реализации коллекций?
List — упорядоченный список, в котором у каждого элемента есть индекс.
Дубликаты значений допускаются.
Set — это неупорядоченное множество уникальных элементов.
Queue — очередь. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция FIFO (first in, first out) — «первым пришёл — первым ушёл».
Map состоит из пар «ключ-значение». Ключи уникальны, а значения могут повторяться. Порядок элементов не гарантирован. Map позволяет искать объекты (значения) по ключу.
Map не наследуется от интерфейса Collection, но входит в состав фреймворка Collections.
Методы интерфейса Collection.
boolean add(E obj) - добавляет obj к вызывающей коллекции. Возвращает true, если obj был добавлен к коллекции.
boolean addAll(Collection<? extends Е> с) - добавляет все элементы  к вызывающей коллекции. Возвращает true, если операция удалась (то есть все элементы добавлены). В противном случае возвращает false.
void clear() - удаляет все элементы вызывающей коллекции.
boolean contains(Object obj) - возвращает true, если obj является элементом вызывающей коллекции. В противном случае возвращает false.
boolean containsAll(Collection<?> с) - возвращает true, если вызывающая коллекция содержит все элементы с. В противном случае возвращает false.
boolean equals(Object obj) - возвращает true, если вызывающая коллекция и obj эквивалентны. В противном случае возвращает false.
int hashCode() - возвращает хешкод вызывающей коллекции.
boolean isEmpty() - возвращает true, если вызывающая коллекция пуста. В противном случае возвращает false.
Iterator<E> iterator() - возвращает итератор для вызывающей коллекции.
boolean remove(Object obj) - удаляет один экземпляр obj из вызывающей коллекции. Возвращает true, если элемент удален. В противном случае возвращает false.
boolean removeAll(Collection<?> с) - удаляет все элементы из вызывающей коллекции. Возвращает truе, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false.
boolean retainAll(Collection<?> с) - удаляет все элементы кроме входящих из вызывающей коллекции. Возвращает true, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false.
int size() - возвращает количество элементов, содержащихся в коллекции.
Object[] toArray() - возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции.
removeIf(Predicate<? super E> filter) - удаляет элементы из коллекции, соответствующие заданному условию.
Отличие ArrayList от LinkedList? Когда лучше использовать ArrayList, а когда LinkedList?
ArrayList - это список на основе массива.
LinkedList - связанный список на основе элементов и связи между ними.
ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того, в ArrayList нет дополнительных расходов на хранение связки между элементами.
Минусы в скорости вставки/удаления элементов, находящихся не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.
LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.
Одним словом - если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList.
Скорость ставки элемента в начало середину и конец у ArrayList vs LinkedList?
У ArrayList вставка и удаление элементов в конце происходит быстро, а в середину и начало - медленно, потому что приходится сдвигать все элементы после операции с элементом.
Чтоб вставить/удалить элемент в LinkedList необходимо всего лишь поменять ссылки в соседних элементах, поэтому – быстро.
В чём разница между Queue и Deque и Stack?
Queue (одностороняя очередь) - когда элементы можно получить в том порядке, в котором добавляли. FIFO (первым вошёл, первым вышел).
Dequeue (двусторонняя очередь) - можно вставлять/получать элементы из начали и конца.
Stack работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.


Расскажи отличие List от Set?
List хранит объекты в порядке вставки, элемент можно получить по индексу,.
Set не может хранить одинаковых элементов.
List - упорядоченная последовательность элементов (LinkedList, ArrayList, Vector).
Set - это отдельный список неупорядоченных элементов (HashSet, LinkedHashSet, TreeSet).
3 реализации Set -> Упорядоченность в HashSet, LinkedHashSet, TreeSet (Какая упорядоченность в какой и почему)?
К семейству интерфейса Set относятся HashSet, TreeSet и LinkedHashSet.
В множествах Set разные реализации используют разный порядок хранения элементов.
В HashSet порядок элементов на основе hash-таблиц, оптимизирован для быстрого поиска.
В контейнере TreeSet объекты хранятся на основе «деревьев» отсортированными по возрастанию. LinkedHashSet хранит элементы в порядке добавления.
Null в TreeSet?
Только в первом элементе.
С учетом того, что Set, собственно, реализован на основе Map.
В пустой TreeMap/TreeSet можно положить единственный ключ-null, все остальные операции (кроме size() и clear(), кстати) после этого не работают.
Когда мы добавляем ключ null в пустое дерево — он попадает в root, для него не происходит вызова compareTo() и null спокойно занимает своё место в корне дерева. А если дерево не пустое — начинаются попытки сравнения с имеющимся содержимым, и мы получаем ошибку.
В непустой TreeMap/TreeSet положить null-ключ нельзя из-за обязательного вызова compareTo().
Компаратор – это интерфейс, определяющий стратегию сравнения объекта с другими объектами того же типа.
Как работает HashSet?
Класс HashSet реализует интерфейс Set, основан на хэш-таблице, а также поддерживается с помощью экземпляра HashMap. В HashSet элементы не упорядочены, нет никаких гарантий, что элементы будут в том же порядке спустя какое-то время. Операции добавления, удаления и поиска будут выполняться за константное время при условии, что хэш-функция правильно распределяет элементы по «корзинам».
Т.к. класс реализует интерфейс Set, он может хранить только уникальные значения;
Может хранить NULL – значения;
Порядок добавления элементов вычисляется с помощью хэш-кода;
HashSet также реализует интерфейсы Serializable и Cloneable.
Почему в HashSet вместо value не null, а new Object?
HashSet хранит new Object(), потому что в контракте указывается метод remove() который возвращает true, если указанный объект существовал и был удален. Для этого он использует обёртку, HashMap#remove() который возвращает удаленное значение. Если бы мы сохранили null вместо объекта, то вызов HashMap#remove() вернул бы null, что было бы неотличимо от результата попытки удалить несуществующий объект, и контракт HashSet.remove() не мог бы быть выполнен.
Говоря простым языком, HashSet построен практически как HashMap с нулевыми значениями.
Как работает метод contains в ArrayList, LinkedList, HashSet?
Метод contains в Arraylist использует метод indexOf (), который использует в свою очередь метод indexOfRange (). Там совершается обход элементов в цикле и если элемент не null, то вызывается стандартный метод equals (сравнение ссылок).
Тоже самое для LinkedList.
В методе contains HashSet используются «корзины» и поиск объекта происходит сначала по hashcode, а только потом по equals.
Что такое HashMap?
Это ассоциативный массив данных.
Структура данных, которая хранит пары ключ-значение. HashMap это фактически массив (table), который хранит ссылки на связанные списки (LinkedList), в которых и хранятся объекты. Каждому элементу массива соответствует один список.
Как работает HashMap?
HashMap работает по принципам хэширования. Хеширование в простейшем представлении, это – способ преобразования любой переменной/объекта в уникальный код после применения любой формулы/алгоритма к их свойствам. Настоящая функция хеширования, должна следовать следующему правилу: Хеш-функция должна возвращать одинаковый хеш-код всякий раз, когда она применена к одинаковым или равным объектам. Другими словами, два одинаковых объекта должны возвращать одинаковые хеш-коды по очереди.
Что такое Node в HashMap? Что содержит?
Node (узел) это внутренний класс в классе HashMap, имплементирует интерфейс Map.Entry, содержит поля:
hash - хеш текущего элемента, который мы получаем в результате хеширования ключа.
key - ключ текущего элемента. Именно сюда записывается то, что мы указываем первым объектом в методе put().
value - значение текущего элемента. А сюда записывается то, что мы указываем вторым объектом в методе put().
next - ссылка на следующий узел в пределах одной корзины. Список же связный, поэтому ему нужна ссылка не следующий узел, если такой имеется.
newNode() — это метод, который просто возвращает объект класса Node с его полями.
Расскажите подробно, как работает метод put в HashMap?
Первым делом, проверяется существует ли ключ (равен ли null). Если ключ не существует (null), значение помещается в таблицу на нулевую позицию, потому что хеш-код для значения null, это – всегда 0.
На следующем шаге, рассчитывается хеш-значение используя хеш-код ключа, получаемый вызовом метода hashCode().
Теперь вызывается функция indexFor(hash, table.length), для вычисления точной позиции (индекса в массиве), куда будет помещен объект Node.
Объекты Node хранятся в форме LinkedList. Когда объект Node должен быть помещен в определенное место, HashMap проверяет нет ли уже в этом месте записи. Если записи нету, то объект помещается в данную позицию. Если все же в данной позиции уже есть объект, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.
Добавление, поиск и удаление элементов выполняется за константное время, при условии, что хеш-функция должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.

Как работает метод get в HashMap?
get(key): возвращает значение по ключу. Если такого элемента нет, то возвращается значение null.
Способ, которым определяется уникальность ключа в методе put(), имеет ту же логику, которую применяет метод get(). Как только HashMap определяет ключ объекта, переданного в аргументе, он просто возвращает значение соответствующего объекта Node. Если же совпадений не найдено, метод get() вернет null.
Что происходит при коллизии?
Мы начинаем сравнивать ключ и hashcode текущего объекта и тех которые внутри (если конечно их там несколько).
Сначала проверяем равны ли hashcode ключей. Если да, то сравниваем их ключ методом equals.
Если equals возвращает true, значит ключи совпадают по “значению” и hashcode – производится замена, новый объект заменяет тот который уже там находится под тем же ключом,
Если hashcode и “значение” ключа неравны – новый объект добавляется в конец списка.
Как расширяется HashMap? Условия перестраивания HashMap в красно-чёрное дерево?
Первоначальный размер HashMap - 16 бакетов (бакет это ячейка массива).
Когда массив заполняется на 75% (loadFactory = 0,75), размер массива увеличивается в 2 раза, т.е. 32 бакета. И так далее (64, 128 …). При увеличении размера массива все объекты, уже содержащиеся в HashMap, будут распределены уже по новым бакетам с учётом их нового количества.
Каждый бакет содержит в себе ноды (пары ключ-значение), когда эти нодов становится 8, а бакетов 64, то структура Node перестраивается в красно-черное дерево (TreeNode).
- static final int TREEIFY_THRESHOLD = 8 — это «порог» количества элементов в одной корзине, при достижении которого внутренний связный список будет преобразован в древовидную структуру (красно-черное дерево).
- static final int UNTREEIFY_THRESHOLD = 6 — если количество элементов в одной корзине уменьшится до 6, то произойдет обратный переход от дерева к связному списку;
- static final int MIN_TREEIFY_CAPACITY = 64 — минимальная емкость (количество корзин) хеш-таблицы, при которой возможен переход к древовидной структуре. Т.е. если в хеш-таблице по крайней мере 64 бакета и в одном бакете 8 или более элементов, то произойдет переход к древовидной структуре.
Почему Map — это не Collection, в то время как List и Set являются Collection?
Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).
Map  - это совокупность пар "ключ"-"значение". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map.
Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент по заданному ключу.
Может ли null быть ключём в HashMap?
HashMap оперирует с null-ключом без каких-либо проблем. Его hash всегда равен 0.
Как обойти HashMap через for-each?
Метод entrySet() возвращает набор всех элементов в виде объектов Map.Entry.
for (Map.Entry e : names.entrySet()
{System.out.printf("Key: %d  Value: %s \n", e.getKey(), e.getValue());}
Как сравниваются ключи в HashMap?
Метод equals() используется для сравнения ключей.(hashCode())
Что такое бинарное дерево?
Двоичное дерево — структура данных, в которой каждый узел (родительский) имеет не более двух потомков (правый и левый наследник).
Двоичное дерево поиска строится по определенным правилам:
- каждый узел имеет не более двух детей;
- каждое значение, меньшее, чем значение узла, становится левым ребенком или ребенком левого ребенка;
- каждое значение, большее или равное значению узла, становится правым ребенком или ребенком правого ребенка.
Что такое черно-красное дерево?
Это один из видов самобалансирующихся бинарных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла.
Что такое Iterator?
Это интерфейс со способностью перебрать все элементы в коллекции.
Итератор идёт от начала коллекции к её концу: смотрит есть ли в наличии следующий элемент и возвращает его, если таковой находится. На основе этого несложного алгоритма построен цикл forEach.
В чём разница между Iterable и Iterator?
Iterable – интерфейс, который реализуют коллекции.
Простое представление ряда элементов, которые могут быть повторены. Он не имеет никакого состояния итерации. Вместо этого у него есть один метод, который производит Iterator.
iterator() возвращает итератор - то есть объект, реализующий интерфейс Iterator.
Iterator — объект с состоянием итерации.
Он позволяет нам проверить, есть ли в нем больше элементов, используя hasNext(), и перейти к следующему элементу (если есть), используя next(). Так же есть метод remove().
Зачем в итераторе метод remove?
Метод remove() удаляет элемент, на который указывает итератор.
В обычном цикле при итерации по коллекции нельзя изменять размер коллекции,
в итераторе – можно.
Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено IllegalStateException().
ListIterator - что это, в чём отличие от Iterator`а?
ListIterator расширяет свойства интерфейса Iterator, позволяя перемещаться по коллекции в обоих направлениях, изменять содержимое коллекции и получать текущую позицию итератора.
При этом следует помнить, что ListIterator не указывает на конкретный элемент коллекции и его текущая позиция определяется двумя элементами, которые возвращают методы previous() и next(). Таким образом, модификация коллекции осуществляется для последнего элемента, который был возвращен одним из методов previous() или next().
Можно ли с помощью цикла for-each изменить поле объектов, которые находятся в массиве?
И можно ли изменить сам объект?
Элемент из КОЛЛЕКЦИИ в цикле for-each удалить нельзя, т.к. нельзя проводить одновременно итерацию (перебор) коллекции и изменение ее элементов. Итератор этого учесть не может. Значения элементов массива менять можно!
Скорость ставки элемента

