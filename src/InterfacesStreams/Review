Функциональные интерфейсы, основные типы?
Функциональный интерфейс — это интерфейс, который содержит ровно один абстрактный метод, то есть описание метода без тела. Статические методы и методы по умолчанию при этом не в счёт, их в функциональном интерфейсе может быть сколько угодно.
Predicate<T> - проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T.
Consumer<T> - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая. Его подвиды IntConsumer, LongConsumer, DoubleConsumer
Function<T,R> - представляет функцию перехода от объекта типа T к объекту типа R.
Supplier<T> - не принимает никаких аргументов, но должен возвращать объект типа T.
UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T.
BinaryOperator<T> - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T.
Что такое лямбда выражение и ссылка на метод?
Лямбда выражение это компактная запись реализации метода функционального интерфейса.
Лямбда это возможность передачи набора инструкций в виде параметра.
Которые потом можно многократно использовать в разных участках кода.
Основу лямбда-выражения составляет лямбда-оператор  -> он разделяет лямбда-выражение на две части: левая часть содержит список параметров, а правая тело лямбда-выражения, где выполняются все действия.
Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их.
Вместо использования АНОНИМНОГО КЛАССА мы можем использовать ЛЯМБДА-ВЫРАЖЕНИЕ И если это вызывает только один метод, мы можем использовать ССЫЛКА НА МЕТОД.
- статический метод - имя_класса::имя_статического_метод
- на метод экземпляра - объект_класса::имя_метод
- на конструкторе - название_класса::new
Как они связаны с анонимным классом?
Лямбда-выражение, образует реализацию метода, определенного в функциональном интерфейсе.
По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом method reference (ссылка на метод) для непосредственной передачи этого метода.
Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений.
Можно любой анонимный класс (с java 8), который реализует один абстрактный метод заменить на лямбду выражение, если анонимный класс реализует два абстрактных метода, то заменить на лямбду будет невозможно (нельзя изменять переменные содержащиеся в ее методе. трюк с массивом единичной длины).
Анонимный класс генерируется компилятором Java.
Класс для реализации лямбда-выражения создается JVM во время выполнения.


Отличие лямбды от анонимного класса?
Лямбдой реализуется только функциональный интерфейс.
Анонимным классом же можно расширить любой расширяемый класс или реализовать интерфейс с любым количеством абстрактных методов.
Анонимный класс создает новый скоуп, лямбда работает в текущем. Это значит, что объявление переменной с именем, которое уже используется снаружи, в лямбде вызовет ошибку компиляции «variable is already defined», в анонимном классе скроет (shadowing) внешнюю переменную.
Анонимные классы, как создать, где применяются, как создать экземпляр?
Анонимный класс - это локальный класс без имени.
Используется тогда, когда нужно переопределить метод класса или интерфейса.
Анонимные классы позволяют сделать наш код более кратким.
Анонимные классы позволяют одновременно объявить класс и создать его экземпляр.
У него есть доступ к переменным внешнего класса, в том числе к статическим и приватным.
Анонимный класс не может содержать статические переменные и методы.
Может ли лямбда-выражение быть в несколько строк?
Да может, они должны быть обернуты в скобки.
Любой анонимный класс можно заменить на лямбду?
Можно любой анонимный класс, который реализует один абстрактный метод заменить на лямбду выражение - например Runnable, Comparator, Predicate
Если анонимный класс реализует два абстрактных метода, то заменить на лямбду будет невозможно.
Как взаимосвязаны лямбда и функциональный интерфейс?
Лямбда это возможность замены вызова реализации интерфейса с одним методом.
Лямбдой выражением мы просто более компактно записываем вызов метода функционального интерфейса с одним методом.
Что такое Стрим?
Стрим - это последовательность элементов, потенциально бесконечная, с возможность применять к ней, сложные, поэтапные преобразования без цикла и условного оператора.
При этом код имеет простую линейную структуру.
Формат работы со стримом:
Получение стрима -> 0 или более промежуточных операторов -> Терминальный оператор. Обработка (начало вычисления элементов) происходит только после терминального оператора.
Потоки не могут быть использованы повторно.
Как только была вызвана какая-нибудь конечная операция, поток закрывается.
Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream.
Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:
используют специализированные лямбда-выражения, например, IntFunction или IntPredicate вместо Function и Predicate;
поддерживают дополнительные конечные операции sum(), average(), mapToObj().

Какие бывают стримы?
- конечные и бесконечные (iterate без limit, generate)
- последовательные и параллельные
- объектные и примитивные
ПОСЛЕДОВАТЕЛЬНЫМИ (sequential) и ПАРАЛЕЛЬНЫМИ (parallel).
Параллельные потоки позволяет задействовать несколько ядер процессора и тем самым может повысить производительность.
При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно.
Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.
Чтобы получить параллельный стрим, нужно либо вызвать метод parallelStream() вместо stream(), либо превратить обычный стрим в параллельный, вызвав промежуточный оператор parallel. Кроме объектных стримов Stream, существуют специальные стримы для примитивных типов:
- IntStream для int,
- LongStream для long,
- DoubleStream для double
Терминальные и промежуточные методы?
ПРОМЕЖУТОЧНЫЕ ОПЕРАТОРЫ конвеерные
filter - отработает как фильтр, вернет значения, которые подходят под заданное условие
collection.stream().filter(«e22»::equals).count()
sorted - отсортирует элементы в естественном порядке; можно использовать Comparator
collection.stream().sorted().collect(Collectors.toList())
limit - лимитирует вывод по тому, количеству, которое вы укажете
collection.stream().limit(10).collect(Collectors.toList())
skip - пропустит указанное вами количество элементов
collection.stream().skip(3).findFirst().orElse("4")
distinct - найдет и уберет элементы, которые повторяются; вернет элементы без повторов
collection.stream().distinct().collect(Collectors.toList())
peek - выполнить действие над каждым элементом элементов, вернет стрим с исходными элементами
collection.stream().map(String::toLowerCase).peek((e) -> System.out.print("," + e)). collect(Collectors.toList())
map - выполнит действия над каждым элементом; вернет элементы с результатами функций
Stream.of("3", "4", "5").map(Integer::parseInt).map(x -> x + 10).forEach(System.out::println)
mapToInt,
mapToDouble,
mapToLong - Сработает как map, только вернет числовой stream
collection.stream().mapToInt((s) -> Integer.parseInt(s)).toArray()
flatMap,
flatMapToInt,
flatMapToDouble,
flatMapToLong - сработает как map, но преобразует один элемент в ноль, один или множество других
collection.stream().flatMap((p) -> Arrays.asList(p.split(",")).stream()).toArray(String[]::new)

ТЕРМИНАЛЬНЫЕ ОПЕРАТОРЫ
findFirst - вернет элемент, соответствующий условию, который стоит первым
collection.stream().findFirst().orElse("10")
findAny - вернет любой элемент, соответствующий условию
collection.stream().findAny().orElse("10")
collect - соберет результаты обработки в коллекции и не только
collection.stream().filter((s) -> s.contains("10")).collect(Collectors.toList())
count - посчитает и выведет, сколько элементов, соответствующих условию
collection.stream().filter("f5"::equals).count()
anyMatch - True, когда хоть один элемент соответствует условиям
collection.stream().anyMatch("f5"::equals)
noneMatch - True, когда ни один элемент не соответствует условиям
collection.stream().noneMatch("b6"::equals)
allMatch - True, когда все элементы соответствуют условиям
collection.stream().allMatch((s) -> s.contains("8"))
min - найдет самый маленький элемент, используя переданный сравнитель
collection.stream().min(String::compareTo).get()
max - найдет самый большой элемент, используя переданный сравнитель
collection.stream().max(String::compareTo).get()
forEach - применит функцию ко всем элементам, но порядок выполнения гарантировать не может
set.stream().forEach((p) -> p.append("_2"));
forEachOrdered - применит функцию ко всем элементам по очереди, порядок выполнения гарантировать может
list.stream().forEachOrdered((p) -> p.append("_nv"));
toArray - приведет значения стрима к массиву
collection.stream().map(String::toLowerCase).toArray(String[]::new);
reduce - преобразует все элементы в один объект
collection.stream().reduce((c1, c2) -> c1 + c2).orElse(0)
Методы у числовых стримов
sum - Возвращает сумму всех чисел
collection.stream().mapToInt((s) -> Integer.parseInt(s)).sum()
average - Возвращает среднее арифметическое всех чисел
collection.stream().mapToInt((s) -> Integer.parseInt(s)).average()
mapToObj - Преобразует числовой стрим обратно в объектный
intStream.mapToObj((id) -> new Key(id)).toArray()
Полезные методы стримов
isParallel - Узнать является ли стрим параллельным
parallel - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
sequential - Вернуть последовательный стрим, если стрим уже последовательный, то может вернуть самого себя
Способы получения стрима?
Коллекции - collection.stream(), collection.parallelStream()
Значений - Stream.of(значение1, ... значениеN)
Массива - Arrays.stream(массив)
Файла - (каждая строка в файле - отдельным элементом в стриме) Files.lines(путь_к_файлу)
Строки - "строка".chars()
Stream.builder - Stream.builder().add(...)....build()
Stream.iterate - Stream.iterate(начальное_условие, выражение_генерации)
Stream.generate - Stream.generate(выражение_генерации)
В iterate задается начальное условие и выражение - получение следующего значения из предыдущего, то есть Stream.iterate(1, n -> n + 1) будет выдавать значения 1, 2, 3, 4, ... N.
Stream.generate служит для генерации константных и случайных значений, он просто выдает значения соответствующие выражению.
Может ли функциональный интерфейс содержать что-то кроме абстрактного метода?
Функциональный интерфейс - это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.
Наличие 1 абстрактного метода - это единственное условие, таким образом
функциональный интерфейс может содержать так же default и static методы.
Что такое функциональное программирование?
Функциональное программирование - это подход в программировании особого вида, когда акцент программного кода сводится к использованию функций, а не инструкций.
При таком подходе каждая отдельная функция используется как объект.
Плюсы:
Код более понятный, предсказуемый, легкий для чтения (при небольших объемах). Поддерживаются ленивые конструкции - производительность.
Минусы:
Легко писать простые функции, но сложно из них собрать целое приложение.
Слишком абстрактный код, поэтому в большом коде разобраться сложно.
Большой объем затрачиваемой памяти - не хранят состояние, поэтому нужно каждый раз создавать объекты.
Где используется:
Когда нужно выполнять множество различных операций с одним и тем же набором данных: искусственный интеллект, машинное обучение, моделирование речи и зрения.
В чем разница между интерфейсами Comparable и Comparator?
Comparable определяет логику сравнения объекта определенного ссылочного типа внутри своей реализации (по правилам разработчика).
Comparator представляет отдельную реализацию и ее можно использовать многократно и с различными классами.
Comparable обеспечивает единую последовательность сортировки для класса.
Comparator предоставляет возможность создани несколько последовательностей сортировки.
Comparable влияет на исходный класс, т.е. модифицируется фактический класс.
Comparator не влияет на исходный класс, т.е. фактический класс не изменяется.
Comparable предоставляет метод compareTo() для сортировки элементов.
Comparator предоставляет метод compare() для сортировки элементов.
Comparable в пакете java.lang.
Comparator в пакете java.util.
Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки. Пример - класс String, Intreger.
Comparator - имплементится другими классами. Дает возможность отделить реализацию сравнения от класса и сделать несколько реализаций.
Что такое (ссылка на метод) метод референс (method reference)?
Ссылки на методы (Method References) – это компактные лямбда выражения для методов у которых уже есть имя. Если лямбда выражения вызывают только один существующий метод, лучше ссылать на этот метод по его имени.
- статический метод - имя_класса::имя_статического_метод
- на метод экземпляра - объект_класса::имя_метод
- на конструкторе - название_класса::new
Что такое default методы в интерфейсе и для чего они были введены?
Для обратной совместимости.
Метод, логика которого реализована в самом интерфейсе. Имеют ключевое слово default. Появились в Java 8 для упрощения добавление новых методов в интерфейс - не нужно править все классы реализующие интерфейс, сохраняя при этом обратную совместимость с уже написанным кодом.
Добавив новый метод с реализацией по умолчанию, мы остаемся совместимым с исходным кодом с существующими реализациями.
Что такое ленивая инициализация стрима?
Приём в разработке, когда ресурсоемкая операция выполняется только тогда, когда нужен ее результат. Для оптимизации производительности.
Stream API так и работает: мы указываем промежуточные операции, которые нам необходимо произвести и в конце следует завершающая или терминальная операция, которая запускает все вычисления. Промежуточные: map () и filter (), Терминальные: counter(), forEach().
Все способы реализации функционального интерфейса?
- С помощью анонимного класса.
- С помощью лямбда - выражения.
- С помощью ссылки на метод.
- С помощью обычного класса, путем имплементации.
В чем разница map и flatMap?
Общее:
- это промежуточные операции над stream, поэтому возвращают поток
- преобразовывает элементы из одного типа в другой
Отличия:
- результат работы map над 1 элементом входящего потока это всегда 1 элемент результирующего потока.
- в то время, как flatMap производит произвольное число (0 и более) значений для каждого элемента входного потока.

Типичное употребление flatMap: это “сглаживание” входного потока в плоский.
Т.е. если входящий поток состоит из списков (массивов), то результатом будет плоский стрим из всех элементов этих списков (массивов).
К каким переменным можно обращаться внутри лямбды?
Ко всем «видимым» переменным
Имеют доступ ко всем переменным, которые им «видны» из того места, где они объявлены.
Но лямбда не должна их изменять (присваивать новое значение).
- К параметрам лямбды, а также свободно объявлять и использовать любые переменные.
- К полям (переменным) того класса внутри которого объявлена лямбда, можно как читать, так и писать. В том числе и к статическим.
- К переменным, которые объявлены внутри метода где объявлена лямбда.
Но есть ограничения - переменные должны быть эффективно финальные. т.е. значение им должно присвоено ровно один раз до объявления лямбды, и после оно меняться не может.
Для обхода этого ограничения используют трюк, достаточно лишь создать переменную ссылочного типа и менять внутреннее состояние объекта. При этом сама переменная будет указывать на тот же объект, и в таком случае можно смело указывать её как final.
Для чего нужны методы forEach() и forEachOrdered()?
forEach() применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется.
forEachOrdered() применяет функцию к каждому объекту стрима с сохранением порядка элементов.
Методы peek и forEach в чем разница?
peek - промежуточный.
Выполнит действие над каждым элементом элементов, вернет стрим с исходными элементами.
forEach - терминальный, ну и функционал какой у каждого.
Применит функцию ко всем элементам, но порядок выполнения гарантировать не может.
По сути оба метода делают одно и тоже - производят действие над каждым элементом потока. Но, метод peek промежуточный, его часто используют для отладки, чтобы посмотреть промежуточное состояние потока.
Optional (зачем нужен)?
Optional - это контейнер для объекта, который может содержать или не содержать значение null. Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/notNull проверок.
Чем Stream отличается от итератора?
Итератор это простой объект который умеет выдавать элементы по одному.
Stream гораздо более сложный и навороченный, у него огромное количество методов.
Он содержит не только средства обхода элементов, но и
- описания
- обработки
- преобразования последовательности элементов
В чем разница между Collection и Stream?
- Collection для хранения, Stream для обработки.
- Коллекции позволяют работать с элементами по-отдельности, стримы так делать не могут. Вместо этого дают возможность выполнять функции над данными как над одним целым.
- Collection - это прежде всего воплощение Структуры Данных.
Например, Set это множество  уникальных элементов, тогда как Stream, это прежде всего абстракция необходимая для реализации конвейера вычислений.
Как получить стрим диапазона чисел?
IntStream smalInteger = IntStream.range(0, 100)
IntStream smallInteger2 = IntStream.rangeClosed(0, 100) - включает последний элемент (100)
Можно ли конкатенировать стримы? Если да, то каким методом?
IntStream cobiedStream = IntStream.concat(stream1,stream2) – конкатенация

Можно ли получить пустой стрим?
Да можно!
IntStream empty = IntStream.empty() - пустой стрим
Отличия Абстрактного класса от интерфейса?
Интерфейс определяет только поведение.
Он не сообщает ничего про объект, который будет его реализовывать.
Абстрактный же класс описывает некий абстрактный объект
(автомобиль, человека, кота и т. д.), а не только поведение.
Что нельзя создать в анонимном классе?
- статические переменные и методы.
- конструкторы (ни определять, ни переопределять).
Аргументы в круглых скобках, стоящих за именем родительского класса, неявно передаются конструктору родительского класса.
