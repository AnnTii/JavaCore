1) что такое ООП.
Объектно-ориентированное программирование – это подход, при котором вся программа рассматривается как набор взаимодействующих друг с другом объектов. У каждого объекта в системе есть свойства и поведение, как и у любого реального объекта.
При этом нам важно знать их характеристики.
2) принципы ООП
Абстракция
это процесс отображения только значимой информации путем сокрытия других деталей.
позволяет отобрать главные характеристики и опустить второстепенные.
Инкапсуляция
сокрытие поведения объекта внутри него. способ спрятать сложную логику внутри класса.
Наследование
С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.
позволяет выделить общее в один объект
описать новый класс на основе уже существующего с частично или полностью заимствованным функционалом.
Полиморфизм
переопределение поведения.
принцип «один интерфейс — множество реализаций».
При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.
Например, метод print может вывести текст на экран, распечатать его на бумаге или вовсе записать в файл.
3) Модификаторы доступа
public:  Видимый для всех
private:  Видимый только для класса
protected: Видимый в том же пакете, что и наш и в пределах классов-наследников нашего класса.
default: Видимый в пакете
4) Указатели this и super.
this: используются для обращения к переменным текущий экземпляр класса
super: используются для обращения к переменным его суперкласса

Так же могут использоваться для вызова конструкторов класса
5) Модификатор static
Static:  модификатор, говорит о том, что метод или поле класса принадлежат не объекту, а классу. Т.е. доступ можно будет получить и не создавая объекта класса.
На методы, объявленные как static, накладывается ряд ограничений.
Они могут вызывать только другие статические методы.
Они должны осуществлять доступ только к статическим переменным.
Они не могут ссылаться на члены типа this или super.
6) Наследование и реализация.
Наследование: С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.
Реализация: Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника ключевое слово extends,
7) Интерфейсы.
Интерфейсы: определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. Ключевое слово interface.
8) Анонимные классы.
Анонимные классы: не имеют имени и их создание происходит в момент инициализации объекта.
Полезны, если нам необходимо один раз создать объект подобного класса.
9) Класс Object и класс Class.
Object: суперкласс и все классы являются его подклассами.
Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса.
Class: классы тоже является объектами, и они принадлежат классу Class.
У класса Class нет публичных конструкторов.
10) Контракт между  equals() и hashCode().
1) Если два объекта равны (т. е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.
2) Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.
3) Одинаковый хэш-код может быть у двух разных объектов.
hashCode() - 32-битное значение типа int.
11) Полиморфизм и его примеры
Полиморфизм
Полиморфизм позволяет нам определять один интерфейс и иметь несколько реализаций.
Например у нас есть класс Animal, у которого есть метод sound() - общий для всех.
System.out.println("Animal is making a sound")
Допустим, что мы имеем два подкласса класса Animal: Horse и Cat, который расширяет(см. наследование) класс Animal.
Horse System.out.println("Neigh")
Cat System.out.println("Meow")
У нас было общее действие для всех подклассов sound(), но были разные способы сделать одно и то же действие.
Это прекрасный пример полиморфизма(функция, которая позволяет нам выполнять одно действие разными способами).
12) Что такое перегрузка метода в Java?
Перегрузка метода: мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров.
13) Какие модификаторы доступа могут быть у класса?
Public, default
14) Может ли статический метод быть перегружен? Будет ли работать переопределение статического метода?
Статический метод может быть перегружен как и любой метод.
Статические методы не могут быть переопределены, поскольку они являются частью класса, а не объекта.
15) Можно ли использовать статические методы в обычных? Наоборот? Почему?
Статические методы можно вызывать и из статических методов, и из обычных.
Статические методы не могут обращаться к обычным переменным класса.
Не знает, из какого экземпляра класса ему брать значения обычных переменных, а может быть что и вовсе ниодин экземпляр класса не создан.
Нельзя вызывать обычный метод из статического, не указывая ссылку на объект!
16) В чем разница (obj instanceof Student) (getClass () == obj.getClass ())
instanceof: возвращает true, если объект является экземпляром класса (объект - это экземпляр класса) или его потомком.
getClass(): == ... проверяет идентичность типов.
То есть, если getClass() проверяет полную идентичность класса, то instanceof вернет true даже если объект будет всего лишь подтипом.
17) Из-за чего происходят коллизии? Почему нельзя написать hashcode гарантировано без коллизий?
hashcode это число int - integer диапазон от -2147483648 до 2147483647, т.е. округлив получаем 4 миллиарда разных целых чисел.
представим ситуацию, у вас 8-10 миллиардов объектов. Им никак не выдать уникальный код.
18) Может ли быть конструктор у абстрактного класса? Для чего?
Да, в абстрактном классе можно объявить и определить конструкторы.
В абстрактном классе могут быть неабстрактные свойства, поля и методы. Их то и нужно в этом конструкторе инициализировать.
Поскольку создавать экземпляры абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов, то есть при создании экземпляра конкретного класса-реализации.
19) Передача параметров по ссылке или по значению? Как передаются объекты в метод?
Java всегда передает параметры по значению
Это означает — "скопировать значение и передать копию."
Передача по значению (by value). Значения параметров копируются. Вызываемый метод создает свою копию значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это никак не влияет.
Передача по ссылке (by reference). Параметры передаются как ссылка (адрес) на исходную переменную. Вызываемый метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные в вызываемом методе, также будут отражены в исходном значении.
Java переменные хранятся следующим образом:
Локальные переменные, такие как примитивы и ссылки на объекты, создаются в стеке.
Объекты — в куче (heap).
20) Можно ли создать поля в интерфейсе?
Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.
21) Можно ли создавать статик методы в интерфейсах?
Да, статические методы в интерфейсах не наследуются.
Это означает, что если вы хотите вызвать такой метод, вы должны вызвать его напрямую из интерфейса, а не из реализующего его класса.
Очень полезно для избежания проблем при множественном наследовании. Представьте, что у вас есть класс, реализующий два интерфейса. У каждого из интерфейсов есть статический метод с одинаковым именем и сигнатурой.
22) Какие модификаторы доступа можно использовать в интерфейсе и абстрактом классе?
Интерфейс - private, static, private static, default.
Абстрактный класс - public, default
23) Как реализована неизменность String?
1) final 2) нет сеттеров 3) модификатор значения private
24) Что такое нативные методы, их плюсы и минусы?
Собственный метод реализуется на языке, отличном от Java (например С, С++...).
плюсы: можно обратиться напрямую к операционной системе;
возможность использования библиотек других языков.
минусы: просадка производительности; теряется статическая типовая информация.
25) Что такое статическое и динамическое связывание?
Присоединение вызова метода к телу метода называется  связыванием.
Статическое связывание в Java происходит во время компиляции
динамическое связывание происходит во время выполнения.
private, final и static методы и переменные используют статическую привязку и связаны компилятором, тогда как виртуальные методы связаны во время выполнения на основе объекта времени выполнения.
Перегруженные методы связываются с использованием статического связывания, а переопределенные методы связываются с использованием динамического связывания во время выполнения.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как final (приватные методы являются final по умолчанию).
26) Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если передать примитив?
массив - это объект, находящийся в куче(она же хип), который может хранить данные, например примитивы.
Передавая массив(объект) в метод, мы получаем копию ссылки, по ссылке мы можем изменить состояние объекта в хипе,
но не можем поменять саму ссылку.
При передаче в метод примитива, у нас создаётся копия, само значение это никак ни повлияет.
27) Различия между ранним и поздним связыванием
Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.
ранее связывание (его ещё называют статическим), во время компиляции на основе типа ссылочной переменной
позднее (соответственно, динамическое) во время выполнения, с использованием конкретных объектов.
Статическое связывание используется для разрешения перегруженных методов
Динамическое связывание используется для разрешения переопределенных методов.
28) Что такое абстрактный класс?

Класс, содержащий абстрактные методы, называется абстрактным классом.
В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников.
Если нам нужно поведение — необходимо использовать интерфейс.
Если речь про концептуальный объект — мы должны использовать абстрактный класс.
Особенность абстрактных классов в том, что их можно использовать только как родительский класс, то есть вы не можете создать объект. Для их объявления используется ключевое слово abstract. Это может понадобиться, чтобы объединить реализацию других схожих классов.
29) Синтаксические отличия интерфейса от абстрактного класса?
abstract для создания абстрактного класса можно использовать с методами.
interface для создания интерфейса нельзя использовать с методами.

extends для расширения абстрактного класса
implements для реализации интерфейсов

абстрактные класы могут иметь методы с реализацией
интерфейс не может иметь никаких реализаций методов
абстрактные класы могут иметь конструкторы
интерфейс нет
Подкласс может расширять только один абстрактный класс, но он может реализовывать несколько интерфейсов
Мы можем запустить абстрактный класс, если у него есть метод main () , но мы не можем запустить интерфейс, потому что у них не может быть реализации метода main

----------------------------------------------------------------------
3.2.1

Если следовать духу ООП, то наша программа будет разбита на маленькие классы, каждый из которых слабо связан с
остальными и сильно специализирован. То есть решает они делают всё сразу. Когда количество классов нашей программе
переваливает за десяток, то возникает потребность как-то наши классы упорядочивать и структурировать. Для этого в
Java есть пакет. О них то мы сейчас поговорим. Принадлежность класса к пакету обозначается директивой package в самом
начале файла с исходным кодом класса:

package org.stepic.java;

public class HelloWorld {
    // ...
}

Обычно эта директива идёт первой же строчкой. Перед ней могут быть только комментарии. Вот это "org.stepic.java" -
имя пакета. С учётом того что класс HelloWorld находится в этом пакете полное имя будет "org.stepic.java.HelloWorld".

Когда вы запускаете виртуальную машину командой java то ей всегда нужно передавать полное имя класса:
"java org.stepic.java.HelloWorld". Если в файле несколько классов, то директива package действует на всех.
В отсутствие директивы package, класс принадлежит пакету по умолчанию, а полное имя класса совпадает с его
коротким именем HelloWorld.

В Java принято раскладывать исходники в соответствии с их пакетами. Исходный код такого класса должен находиться
в файле org/stepic/java/HelloWorld.java. То же справедливо и для скомпилированного байт-кода. Class-файлы будут
разложены компилятором по директориям в соответствии с их пакетами: org/stepic/java/HelloWorld.class.

Это важно для виртуальной машины, которая, когда ей потребуется загрузить класс с таким "org.stepic.java.HelloWorld"
полным именем, будет искать его строго в файле с таким именем "org/stepic/java/HelloWorld.class" и нигде больше.

Пакеты в Java напоминают ... и C  . Пакет задает область видимости класса. Другие классы этого же пакета могут
обращаться к классу HelloWorld по его короткому имени. Классы из других пакетов должны ссылаться на класс HelloWorld
по его полному имени, либо использовать директиву "import org.stepic.java.HelloWorld;".

Импортировать можно либо конкретные классы, либо всё содержимое пакета сразу
(как например вот здесь: import java.util.*;. Кстати, такие классы как Integer и прочие обёртки (String, System),
с которыми мы уже имели дело, на самом деле находятся в стандартном пакете java.lang. Однако импортировать нам их не
приходилось. Это потому что в любой java-программе подразумевается неявный импорт всех классов из пакета java.lang.
Классы этого пакета всегда доступны по их коротким именам.

Интересная особенность - классы из пакета по умолчанию невозможно использовать из других пакетов,
даже при наличии явного импорта.

Есть еще одна форма директивы import - import static, которая позволяет импортировать статические поля и методы:
import static java.lang.Math.sqrt;
import static java.lang.System.out;.
То есть в тексте программы можно будет обращаться к ним, не указывая имя класса. Например,
sqrt(4) или out.println("foo").

Также есть вариант со звёздочкой, который одним махом импортирует сразу все статические поля и методы из
класса: import static java.lang.Math.*;. Иногда удобно, но злоупотреблять этим не стоит.

Подчеркну, что директива import служит только для одной цели - она позволяет в исходном коде вашей программы
ссылаться на импортированные классы по их коротким именам. Никакой подстановки тела импортированных классов в ваш файл
не происходит. То есть это не аналог директивы include из С. Когда ваша программа исполняется в виртуальной машине, то
все импортированные классы также должны присутствовать в classpath.

-----------------------------------------------------------------------

3.2.2

Классы стандартной библиотеки Java находятся в пакетах с префиксами java и javax:
java.lang
java.io
java.nio
java.math
java.time
java.util
java.util.regex
javax.xml
...
 Здесь я привел пакеты, классы из которых используются чаще всего. Копаясь в jar-ах, входящих в состав jre,
 вы можете также наткнуться на пакеты com.oracle, com.sun, sun и массу классов в них. Эти классы являются спецификой
 реализации оракловой джавы и не предназначены для использования прикладными программистами.

Во-первых, они доступны только в реализации Java от Oracle. Соответственно программа использующая их не будет
переносимой. А во-вторых, нет никаких гарантий, что эти классы не будут удалены, переименованы или другим несовместимым
образом изменены в следующей версии Java.

Для пользовательских пакетов в Java существует следующее соглашение - пакеты принято называть в соответствии с
доменными именами компании, продукта или проекта, в рамках которых этот код написан. Например, для моего курса на
stepic.org согласно этой рекомендации имя пакета должно начинаться с org.stepic. Код, который пишут компании Google,
будет в пакетах начинающихся на com.google. Многие проекты, исходники которых хостятся на sourceforge имеют имя пакета
начинающееся на net.sf.
org.stepic.java
com.google.common
org.apache.maven
com.intellij.idea
net.sf.json
io.netty
...

Внутри уже можно заводить произвольную структуру подпакетов.

Смысл правила про использование доменных имен при именовании пакетов состоит в том, чтобы снизить вероятность коллизии
имен классов, написанных разными людьми. Благодаря этому можно например найти в интернете библиотеку, скачать jarник,
подключить к своей программе и не беспокоиться о том, что классы из этого jarа будут конфликтовать с классами вашей
программы или классами других подключенных библиотек.

Помимо задания области видимости и предотвращения коллизий имён, пакеты могут служить для группировки связанных классов
внутри программы. Например, все классы относящиеся к ядру программы могут быть собраны в пакете core, разнообразные
утилитные классы в пакете util, подключаемые модули в пакете plagins.

-----------------------------------------------------------------------

3.2.3

И еще одна функция пакетов - это инкапсуляция на более высоком уровне чем классы. При помощи модификаторов доступа
можно сделать класс, метод или поле доступным только в пределах пакета. То есть можно скрыть какие-то детали реализации
внутри пакета так, что они будут недоступны классам из других пакетов. Это особенно важно, когда вы например пишете
библиотеку, которую будут использовать другие программисты. В этом случае вам нужно выставить наружу только строго
определенное подмножество классов и методов, а всё остальное - детали реализации вашей библиотеки - максимально скрыть.

Казалось бы, кому могут понадобиться ваши внутренние классы? Так же думали и разработчики Sun Microsystems, и вот
теперь мы имеем огромное количество программ, зависящих от классов c пакетов sun.misc или com.sun, которые никогда
не были предназначены для широкого использования. Так что не надо недооценивать сообразительность и длину рук
программистов, которые будут использовать написанный вами код.

Против длинных рук других программистов помогут специальные ключевые слова - модификаторы, устанавливающие правила
доступа к вашим классам, их полям и методам.
public class ModifiersDemo {
    public static void visibleEverywhere() {}
    protected static void inSubclasses() {}
    static void inPackage() {}
    private void inClass() {}
}
В Java есть 4 типа доступа:
1) public - разрешен доступ отовсюду, без ограничений.
2) protected - доступ разрешен только для классов-наследников и для классов текущего пакета.
3) Отсутствие модификатора означает доступ только в пределах пакета.
4) private - доступ только в пределах класса.

Модификаторы protected и private неприменимы к классам верхнего уровня, их можно применять к вложенным классам.
Но о вложенных классах мы поговорим отдельно. Также в некоторых контекстах отсутствие модификатора означает не пакетную
видимость, а что-то другое, но об этом мы тоже будем говорить потом, когда придет время.

Стоит хорошенько думать о том, какие элементы вашей программы вы выставляете в общее пользование, а какие нет.
Если сомневаетесь, то лучше поставьте более строгий модификатор доступа. Если в один прекрасный момент действительно
появится реальная необходимость переиспользовать ваш код в другом месте, то поставить другой модификатор доступа будет
нетрудно. А вот если вы изначально объявили ваш класс как публичный, а потом передумали, то вам возможно придется
перелопатить не маленькое количество кода, где ваш класс таки могли успеть использовать. И вообще, далеко не всегда
вам доступен весь код, где могут использоваться ваши классы. Например, если вы выкладываете библиотеку в интернет,
то вы уже ничего не контролируете и фактически вы подписываетесь поддерживать обратную совместимость. То есть не
удалять, не переименовывать и не менять другим несовместимым образом ничего из публичных классов, методов и полей.
Пользователи очень не любят, когда новая версия библиотеки ломает им их код.

-----------------------------------------------------------------------

3.3.1

Разберем теперь подробно объявление класса, какие ключевые слова могут использоваться в объявлении класса, что они
означают, и вообще, чем может быть класс наполнен. Для данного урока я подобрал примеры из стандартной библиотеки
Java в реализации от Oracle. Так что мы немножко даже заглянем в исходники стандартной библиотеки. Но должен
предупредить, что код приведён со значительными сокращениями, чтобы не отвлекаться на вещи, которые мы, например,
ещё не знаем и сосредоточиться на главном.

Итак, приступим. Класс объявляется ключевым словом class с именем класса и модификатором доступа.

pakcage java.lang;

/**
*
*
*/
public final class Integer {
//...
}


В случае класса верхнего уровня может использоваться модификатор public или модификатора может не быть, что означает
видимость класса в пределах пакета. Модификаторы private и protected здесь лишены смысла. Напомню, что в одном исходном
файле друг за другом может быть объявлено несколько классов, но пабликом может быть только один из них и его имя
обязана совпадать с именем файла. Ключевое слово  final в объявлении класса означает, что от данного класса нельзя
наследоваться, то есть он является финальным в иерархии наследования. Подробнее про наследование мы поговорим на
следующем уроке. Любой элемент программы - класс, метод или поле - может сопровождаться Javadoc -комментарием.
Классы стандартной библиотеки снабжены хорошими подробными джавадоками. Поэтому часто можно решить какой-то вопрос
по использованию класса стандартной библиотеки просто почитав их Javadoc. Необязательно сразу лезть на stackoverflow.

-----------------------------------------------------------------------

1) что такое ООП.
Объектно-ориентированное программирование – это подход, при котором вся программа рассматривается как набор
взаимодействующих друг с другом объектов. При этом нам важно знать их характеристики. У каждого объекта в системе
есть свойства и поведение, как и у любого реального объекта.
2) принципы ООП
Абстракция
это процесс отображения пользователю только необходимой информации путем сокрытия других деталей.
Инкапсуляция сокрытие поведения объекта внутри него. способ спрятать сложную логику внутри класса, предоставив
программисту лаконичный и понятный интерфейс для взаимодействия с сущностью.
Наследование позволяет выделить общее в один объект
легко и просто расширить существующий класс, дополнив его функциональностью.
Полиморфизм переопределение поведения.
принцип «один интерфейс — множество реализаций». Например, метод print может вывести текст на экран, распечатать
его на бумаге или вовсе записать в файл.
3) Модификаторы доступа
public:  Видимый для всех
private:  Видимый только для класса
protected: В пределах всех классов, находящихся в том же пакете, что и наш.
В пределах всех классов-наследников нашего класса.
default: Видимый в пакете
4) Указатели this и super.
this: используются для обращения к переменным текущий экземпляр класса
super: используются для обращения к переменным его суперкласса

Так же могут использоваться для вызова конструкторов класса
5) Модификатор static
Static:  модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на
привязку субъекта  к текущему классу.
6) Наследование и реализация.
Наследование: С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового
функционала или изменения старого.
Реализация: Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника
ключевое слово extends,
7) Интерфейсы.
Интерфейсы: определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы,
применяющие эти интерфейсы. Ключевое слово interface.
8) Анонимные классы.
Анонимные классы: не имеют имени и их создание происходит в момент инициализации объекта.
Полезны, если нам необходимо один раз создать объект подобного класса.
9) Класс Object и класс Class.
Object: суперкласс и все классы являются его подклассами.
Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса.
Class: классы тоже является объектами, и они принадлежат классу Class.
У класса Class нет публичных конструкторов.
10) Контракт между  equals() и hashCode().
1) Если два объекта равны (т. е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.
2) Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать
одно и то же число.
3) Одинаковый хэш-код может быть у двух разных объектов.
hashCode() - 32-битное значение типа int.
11) Полиморфизм и его примеры
Полиморфизм: это способность объекта принимать различные формы.
Полиморфизм позволяет нам определять один интерфейс и иметь несколько реализаций.
Например у нас есть класс Animal, у которого есть метод sound() - общий для всех.
System.out.println("Animal is making a sound")
Допустим, что мы имеем два подкласса класса Animal: Horse и Cat, который расширяет(см. наследование) класс Animal.
Horse System.out.println("Neigh")
Cat System.out.println("Meow")
У нас было общее действие для всех подклассов sound(), но были разные способы сделать одно и то же действие.
Это прекрасный пример полиморфизма(функция, которая позволяет нам выполнять одно действие разными способами).
12) Что такое перегрузка метода в Java?
Перегрузка метода: мы можем использовать методы с одним и тем же именем, но с разными типами и/или
количеством параметров.
13) Какие модификаторы доступа могут быть у класса?
Public, default
14) Может ли статический метод быть перегружен? Будет ли работать переопределение статического метода?
Статический метод может быть перегружен как и любой метод.
Статические методы не могут быть переопределены, поскольку они являются частью класса, а не объекта.
15) Можно ли использовать статические методы в обычных? Наоборот? Почему?
Статические методы можно вызывать и из статических методов, и из обычных.
Статические методы не могут обращаться к обычным переменным класса.
Не знает, из какого экземпляра класса ему брать значения обычных переменных, а может быть что и вовсе
ниодин экземпляр класса не создан.
Нельзя вызывать обычный метод из статического, не указывая ссылку на объект!
16) В чем разница (obj instanceof Student) (getClass () == obj.getClass ())
instanceof: проверяет, является ли ссылка на объект с левой стороны экземпляром типа с правой стороны или
некоторым его подтипом.
getClass(): == ... проверяет идентичность типов.
17) Из-за чего происходят коллизии? Почему нельзя написать hashcode гарантировано без коллизий?
hashcode это число int - integer диапазон от -2147483648 до 2147483647, т.е. округлив получаем 4 миллиарда
разных целых чисел.
представим ситуацию, у вас 8-10 миллиардов объектов. Им никак не выдать уникальный код.
18) Может ли быть конструктор у абстрактного класса? Для чего?
Да, в абстрактном классе можно объявить и определить конструкторы.
Его можно использовать для задания начальных значений общих переменных.
19) Передача параметров по ссылке или по значению? Как передаются объекты в метод?
Java всегда передает параметры по значению
Передача по значению (by value). Значения фактических параметров копируются. Вызываемый метод создает свою копию
значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это никак не влияет.
Передача по ссылке (by reference). Параметры передаются как ссылка (адрес) на исходную переменную. Вызываемый
метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные в вызываемом
методе, также будут отражены в исходном значении.
Java переменные хранятся следующим образом:
Локальные переменные, такие как примитивы и ссылки на объекты, создаются в стеке.
Объекты — в куче (heap).
20) Можно ли создать поля в интерфейсе?
Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final).
Все методы и переменные неявно объявляются как public.
21) Можно ли создавать статик методы в интерфейсах?
Да, статические методы в интерфейсах не наследуются. Это означает, что если вы хотите вызвать такой метод,
вы должны вызвать его напрямую из интерфейса, а не из реализующего его класса.
Очень полезно для избежания проблем при множественном наследовании. Представьте, что у вас есть класс, реализующий
два интерфейса. У каждого из интерфейсов есть статический метод с одинаковым именем и сигнатурой.
22) Какие модификаторы доступа можно использовать в интерфейсе и абстрактом классе?
Интерфейс - private, private static, default.
Абстрактный класс - public, default
23) Как реализована неизменность String?
1) final 2) нет сеттеров 3) модификатор значения private
24) Что такое нативные методы, их плюсы и минусы?
реализуется на языке, отличном от Java (например С, С++...).
плюсы: можно обратиться напрямую к операционной системе;
возможность использования библиотек других языков.
минусы: просадка производительности; теряется статическая типовая информация.
25) Что такое статическое и динамическое связывание?
Присоединение вызова метода к телу метода называется  связыванием.
Статическое - связывание проводится компилятором (компоновщиком)  перед запуском программы.
Динамическое - связывание, проводимое непосредственно во время выполнения  программы, в зависимости от типа объекта.
Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен
как final (приватные методы являются final по умолчанию).
26) Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему?
А если передать примитив?
массив - это объект, находящийся в куче(она же хип), который может хранить данные, например примитивы.
Передавая массив(объект) в метод, мы получаем копию ссылки, по ссылке мы можем изменить состояние объекта в хипе,
но не можем поменять саму ссылку.
При передаче в метод примитива, у нас создаётся копия, само значение это никак ни повлияет.
27) Синтаксические отличия интерфейса от абстрактного класса?
abstract для создания абстрактного класса можно использовать с методами.
interface для создания интерфейса нельзя использовать с методами.

extends для расширения абстрактного класса
implements для реализации интерфейсов

абстрактные класы могут иметь методы с реализацией
интерфейс не может иметь никаких реализаций методов
абстрактные класы могут иметь конструкторы
интерфейс нет
Подкласс может расширять только один абстрактный класс, но он может реализовывать несколько интерфейсов
Мы можем запустить абстрактный класс, если у него есть метод main () , но мы не можем запустить интерфейс,
потому что у них не может быть реализации метода main

