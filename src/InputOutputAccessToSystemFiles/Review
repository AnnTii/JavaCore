INPUTSTREAM и OUTPUTSTREAM
Что такое InputStream и OutputStream.
InputStream — абстрактный класс, описывающий входной поток байт. Все методы класса предназначены для чтения байт, при возникновении ошибки они возбуждают исключение IOException.
OutputStream - это абстрактный класс, определяющий байтовый поток вывода. Наследники данного класса определяют куда направлять данные: в массив байтов, в файл или канал. Из массива байт можно создать текстовую строку String.
На каком паттерне основана иерархия потоков ввода/вывода.
На паттерне Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.
Отличие пакетов IO и NIO, InputStream от Reader.
Java IO является потокоориентированным, блокирующий ввод/вывод (синхронный)
Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно.
Java NIO – буфер-ориентированным, неблокирующий ввод/вывод (асинхронный)
Буфер-ориентированные данные считываются в буфер для последующей обработки. Мы можем двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных.
InputStream - это необработанный метод получения информации от ресурса. Он захватывает байты данных байтом без какого-либо перевода - используется если читаются данные изображения, видео или любой двоичный файл.
Reader предназначен для потоков символов. Если информация, которую мы читаем, является всем текстом, то Reader позаботится о расшифровке символов для нас и даст нам символы Unicode из исходного входного потока – для считывания текста.
Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?
InputStream представляет классы, которые получают данные из различных источников:- массив байтов- строка (String)- файл- канал (pipe): данные помещаются с одного конца и извлекаются с другого- последовательность различных потоков, которые можно объединить в одном потоке- другие источники (например, подключение к интернету).
OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String; предполагается что вы сможете создать их из массива байтов), в файл или канал.
Символьные потоки имеют два основных абстрактных класса Reader и Writer, управляющие потоками символов Unicode.
Reader - абстрактный класс, определяющий символьный потоковый ввод.
Writer - абстрактный класс, определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение IOException.

Какие интерфейсы реализует InputStream/ OutputStream/ Reader/ Writer?
InputStream - Closeable, AutoCloseable
OutputStream - Closeable, Flushable, AutoCloseable
Reader - Closeable, AutoCloseable, Readable
Writer - Closeable, Flushable, Appendable, AutoCloseable

Пример адаптера и декоратора из IO?
Адаптер - посредник, переходник. Например, конвертировать данные одного формата в другой формат, чтобы две независимые библиотеки могли договориться друг с другом (например, XML и JSON).
Декоратор это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки. Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.
Декоратор предоставляет улучшенный интерфейс.
Адаптер изменяет интерфейс объекта, Декоратор улучшает обязанности объекта.
Адаптер это структурный паттерн, который позволяет подружить несовместимые объекты. Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

Что такое «каналы»?
Каналы - это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы - внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.
Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов.
Потоки (streams) применительно к вводу/выводу и работе с файлами. – Абстракция, которая используется для чтения или записи информации (файлов, сокетов, текста консоли и т.д.).
Что такое поток?
Поток это— это объект класса, который наследует класс Thread или реализует интерфейс Runnable. Поскольку это объект, то на него создаётся ссылка. Ссылка записывается в объектную переменную. Эта объектная переменная может относиться к классу Thread.

Что такое многопоточность?
Многопоточность — это два и более потоков, выполняющихся одновременно в одной программе. Компьютер с одноядерным процессором может выполнять только один поток, разделяя процессорное время между различными процессами и потоками.
Thread и Runnable, что выбрать? Зачем нужно два вида реализации многопоточности?
Реализация интерфейса Runnable используется в случаях, когда класс уже наследует какой-либо родительский класс и не позволяет расширить класс Thread. К тому же хорошим тоном программирования в Java считается реализация интерфейсов. Это связано с тем, что в Java может наследоваться только один родительский класс. Таким образом, унаследовав класс Thread, невозможно наследовать какой-либо другой класс.
Расширение класса Thread целесообразно использовать в случае необходимости переопределения других методов класса помимо метода run().

ВВОД/ВЫВОД

Какие существуют виды потоков ввода/вывода?
Разделяют два вида потоков ввода/вывода: байтовые и символьные.
Назовите основные предки потоков ввода/вывода.
Байтовые: java.io.InputStream, java.io.OutputStream;
Символьные: java.io.Reader, java.io.Writer;

В чем отличие Scanner от BufferedReader?
Scanner позволяет разобрать строку на составляющие (токены), с помощью различных разделителей. Он не синхронизирован и, также не выбрасывает исключения.
BufferedReader предназначен для чтения потока символов с буферизацией.
Для чего нужен Scanner?
Класс Scanner используется для получения (считывания) данных введенных пользователем в виде String, byte, short, int, long, float, double. Сканер выполняет поиск токенов во входной строке.

Что такое токен в Scanner?
Токен (или маркер) представляет собой серию цифровых или буквенно-цифровых символов, которая заканчивается разделителем. Разделителем может быть символ табуляции, возврат каретки (перевод строки или же просто ‘Enter’), конец файла или пробел.

Есть ли у сканера буфер?
Да, 1 КБ
Scanner имеется меньший буфер (1024 символа) в отличие от BufferedReader (8192 символов)
Cтандартные потоки ввода/вывода?
Стандартный поток ввода System.in
Имеет тип InputStream, класс InputStream есть абстрактный и размещается в вершине иерархии классов ввода.
Стандартный поток вывода System.out
Имеет тип PrintStream. Класс PrintStream содержит методы вывода на консоль print() и println().
Классы байтовых потоков ввода и что они делают?
InputStream - абстрактный класс, который описывает поток ввода. Данный класс есть базовым для всех других классов системы ввода;
BufferedInputStream - класс, который описывает буферизованные поток ввода; ByteArrayInputStream - класс, который описывает поток ввода, читающий байты из массива; DataInputStream -класс, который реализует методы для чтения данных стандартных типов, определенных в Java (int, double, float и т.д.);
FileInputStream - класс, который реализует поток ввода, который читает данные из файла; FilterInputStream - это реализация абстрактного класса InputStream;
ObjectInputStream - класс, реализующий поток ввода объектов;
PipedInputStream - класс, соответствующий каналу ввода;
PushbackInputStream - класс, соответствующий потоку ввода, который поддерживает возврат одного байта обратно в поток ввода;
SequenceInputStream - класс, который реализует поток ввода, состоящий из двух или более потоков ввода, данные из которых читаются поочередно.
Классы байтовых потоков вывода и что они делают?
OutputStream - абстрактный класс, который описывает поток вывода. Все другие классы системы вывода есть подклассами класса OutputStream;
BufferedOutputStream - класс, который имплементирует буферизованный поток вывода; ByteArrayOutputStream - класс, который реализует поток вывода, записывающий байты в массив; DataOutputStream - класс, который реализует поток вывода, содержащий методы для чтения данных стандартных типов, определенных в Java (int, float, double и т.п.);
FileOutputStream - класс, который соответствует потоку вывода записывающему данные в файл; FilterOutputStream - класс, реализующий абстрактный класс OutputStream;
ObjectOutputStream - класс, соответствующий потоку вывода объектов;
PipedOutputStream - класс, который ассоциируется с каналом вывода;
PrintStream - класс, который представляет собой поток вывода, содержащий методы print() и println().
Классы символьных потоков ввода и что они делают?
Reader - абстрактный класс, описывающий поток ввода символов. Этот класс есть суперклассом для всех нижеследующих подклассов;
BufferedReader - класс, который описывает буферизованный поток ввода символов; CharArrayReader - класс, который реализует поток ввода, читающий символы из массива; FileReader - класс, который описывает поток ввода связанный с символьным файлом;
FilterReader - класс, представляющий фильтрованный поток чтения;
InputStreamReader - класс, который представляет собой поток ввода, превращающий байты в символы;
LineNumberReader - класс, соответствующий потоку ввода, который подсчитывает строки; PipedReader - класс, который ассоциируется с каналом ввода;
PushbackReader - класс, соответствующий потоку ввода, который позволяет возвращать символы обратно в поток ввода;
StringReader - класс, который реализует поток ввода, читающий символы из строки.
Классы символьных потоков вывода и что они делают?
Writer - абстрактный класс, описывающий поток вывода символов. Все нижеследующие классы являются подклассами класса Writer;
BufferedWriter - класс, который описывает буферизованный поток вывода символов; CharArrayWriter - класс, который соответствует потоку вывода, записывающему символы в массив; FileWriter - класс, который соответствует потоку вывода, записывающему символы в файл; FilterWriter - класс, реализующий фильтрованный поток записи;
OutputStreamWriter - класс, реализующий средства преобразования символов в байты; PipedWriter - класс, который ассоциируется с каналом вывода;
StringWriter - класс, который реализует поток вывода, записывающий символы в строку.
Почему важно закрывать потоки?
При закрытии потока освобождаются все выделенные для него ресурсы, например, файл.
В случае, если поток окажется не закрыт, может происходить утечка памяти.
Какие потоки можно не закрывать (не вызывать метод close())?
Можно не закрывать промежуточные потоки, а закрыть только главные. Потоки имеют метод BaseStream. close() и реализуют AutoCloseable , но почти все экземпляры потока на самом деле не нужно закрывать после использования. Как правило, только потоки, источником которых является канал ввода-вывода
Абсолютны и относительный путь.
Абсолютный путь начинается с корневой директории.
Относительный путь считается относительно какой-то директории.



ФАЙЛЫ
Как создать файл на компьютере с помощью java.
1. использовать метод File.createNewFile().
При установлении объекта File вы указываете название файла и дальше используйте метод createNewFile(), который атомарно создает новый пустой файл с названием абстрактного пути, но только в случае, если файл с таким названием не существует.
2. FileOutputStream.write()
Если хотите создать новый файл и одновременно записать какую-нибудь информацию в нем, можете использовать метод FileOutputStream.write. Этот метод автоматически создает новый файл и записывает в нем контент. Используется для записи байтов в файл. Если хотите записать символьно-ориентированную информацию, будет лучше использовать FileWriter.
3. Java NIO. Files.write()
Класс Java NIO Files для создания нового файла и записи информации в нем. Этот Java класс представляет метод write(Path, byte[] bytes, OpenOption... options), который записывает байты к файлу по указанному пути.
4. Java также может создавать временные файлы. createTempFile
Какие есть режимы доступа к файлу?
RandomAccessFile может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.
Что вы знаете о RandomAccessFile?
Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому.
Метод seek() позволяет переместиться к определенной позиции и изменить хранящееся там значение.
Как только указатель файла был помещен, данные могут быть прочитаны и записаны в файл с использованием интерфейсов DataInput и DataOutput. Эти интерфейсы позволяют нам считывать и записывать данные независимым от платформы способом.
Класс RandomAccessFile содержит методы для чтения и записи примитивов и строк UTF-8.
Что делает метод (int) available()?
Возвращает количество байтов ввода, доступные в данный момент для чтения
Можно ли использовать flush() для не буферизированного потока и что будет?
Можно использовать, но ничего не будет.
Буферизация в основном выполняется для повышения производительности ввода-вывода.
flush() нельзя применить для не буферизированного потока. А если и применить, то ничего не произойдёт.
Гарантируется ли запись данных в файл при вызове flush()?
Гарантирует только то, что байты, ранее записанные в поток, передаются операционной системе для записи, но не гарантирует записи на диск.
flush() записывает содержимое буфера в место назначения и делает буфер пустым для дальнейшего хранения данных, но не закрывает поток навсегда. Это означает, что вы все еще можете записать в поток еще несколько данных.


Методы класса File?
boolean createNewFile(): создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает true, иначе false
boolean delete(): удаляет каталог или файл по пути, который передан в конструктор. При удачном удалении возвращает true.
boolean exists(): проверяет, существует ли по указанному в конструкторе пути файл или каталог. И если файл или каталог существует, то возвращает true, иначе возвращает false
String getAbsolutePath(): возвращает абсолютный путь для пути, переданного в конструктор объекта
String getName(): возвращает краткое имя файла или каталога
String getParent(): возвращает имя родительского каталога
boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог
boolean isFile(): возвращает значение true, если по указанному пути находится файл
boolean isHidden(): возвращает значение true, если каталог или файл являются скрытыми
long length(): возвращает размер файла в байтах
long lastModified(): возвращает время последнего изменения файла или каталога. Значение представляет количество миллисекунд, прошедших с начала эпохи Unix
String[] list(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
File[] listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
boolean mkdir(): создает новый каталог и при удачном создании возвращает значение true
boolean renameTo(File dest): переименовывает файл или каталог
Методы интерфейса Path
compareTo(Path other) - Сравнивает два абстрактных пути лексикографически.
endsWith(Path other) - Тесты, если этот путь заканчивается данным путем.
endsWith(String other) - Тесты, если этот путь заканчивается a Path, созданный, преобразовывая данную строку пути, точно способом, определенным endsWith(Path) метод.
equals(Object other) - Тесты этот путь для равенства с данным объектом.
getFileName() - Возвращает имя файла или каталога, обозначенного этим путем как a Path объект.
getFileSystem() - Возвращает файловую систему, которая создала этот объект.
getName(int index) - Возвращает элемент имени этого пути как a Path объект.
getNameCount() - Возвращает число элементов имени в пути.
getParent() - Возвращает родительский путь, или null если у этого пути нет родителя.
getRoot() - Возвращает корневой компонент этого пути как a Path объект, или null если у этого пути нет корневого компонента.
hashCode() - Вычисляет хэш-код для этого пути.
isAbsolute() - Говорит, является ли этот путь абсолютным.
iterator() - Возвращает iterator по элементам имени этого пути.
normalize() - Возвращает путь, который является этим путем с избыточными устраненными элементами имени.
register(WatchService watcher, WatchEvent.Kind<?>... events) - Регистрирует файл, расположенный этим путем со службой часов.
register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) - Регистрирует файл, расположенный этим путем со службой часов.
relativize(Path other) - Создает относительный путь между этим путем и данным путем.
resolve(Path other) - Разрешите данный путь против этого пути.
resolve(String other) - Преобразовывает данную строку пути в a Path и решения это против этого Path точно способом, определенным resolve метод.
resolveSibling(Path other) - Разрешает данный путь против этого пути parent путь.
resolveSibling(String other) - Преобразовывает данную строку пути в a Path и решения это против этого пути - - parent путь точно способом, определенным resolveSibling метод.
startsWith(Path other) - Тесты, если этот путь запускается с данного пути.
startsWith(String other) - Тесты, если этот путь запускается с a Path, созданный, преобразовывая данную строку пути, точно способом, определенным startsWith(Path) метод.
subpath(int beginIndex, int endIndex) - Возвращает родственника Path это - подпоследовательность элементов имени этого пути.
toAbsolutePath() - Возвраты a Path объект, представляющий абсолютный путь этого пути.
toFile() - Возвраты a File объект, представляющий этот путь.
toRealPath(LinkOption... options) - Возвращает реальный путь существующего файла.
toString() - Возвращает строковое представление этого пути.
toUri() - Возвращает URI, чтобы представить этот путь.
Как удалить директорию с файлами. Что если в ней есть вложенные директории ?
Java не может удалять папки с данными.
Для удаления папки с файлами и подкаталогами надо использовать метод delete() с использованием рекурсии.
Если папка пуста, то она удаляется, если в папке что-то есть, то метод delete() просто возвращает false, то есть папка не удаляется.
В чём отличие File от Path?
File — это класс,
Path — это интерфейс.
File — это старый способ доступа к файловой системе,
Path — это новый рекомендуемый способ.
Path более стройный, в нём нет булевских флажков, методы бросают исключения, можно работать с расширенными атрибутами файлов, например с правами доступа или с символическими ссылками, создавать их или узнавать куда ссылка ведёт.
В Path появились методы перемещения и копирования файлов
Path допускает работу с файлами на виртуальных файловых системах, а File нет.
Как работает метод read()?
Метод read() - возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1.
Метод read(byte arr) - метод для массового считывания данных, который считывает максимум байтов (не более arr.length) из потока, входящих данных в аргумент массива arr и возвращает фактическое количество байтов, считанных из потока.
СЕРИАЛИЗАЦИЯ И ДЕСЕРИАЛИЗАЦИЯ
Что такое сериализация и десериализация.
Сериализация - это процесс сохранения состояния объекта в последовательность байт.
Десериализация - это процесс восстановления объекта, из этих байт.
Serialization предоставляет стандартный механизм для создания сериализуемых объектов.
Назовите несколько форматов сериализации.
- JSON
- JavaScript Object Notation
- XML
- BinarySON - тот же JSON только в двоичном представлении.
- YAML - Yet Another Markup Language
Как сериализовать объект класса?
Класс должен имплементировать маркерный интерфейс Serializable.
Создаем ObjectOutputStream и передаем ему OutputStream
Сериализация *.writeObject()
Десериализация *.readObject()
Что делать, если одно из полей сериализовывать не нужно.
Это поле нужно пометить ключевым словом transient. И оно не будет сериализовано.
transient (нерезидент) — модификатор полей класса. Отмеченные этим модификатором поля не записываются в поток байт при применении стандартного алгоритма сериализации.
При десериализации объекта такие поля инициализируются значением по умолчанию.
static поля, не сериализуются. Соответственно, после десериализации это поле значения не меняет.
Как сериализовать статическое поле.
При использовании реализации Externalizable сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.
Какие условия "благополучной" сериализации объекта?
Класс должен реализовывать интерфейс-метку Serializable. Так же все атрибуты и подтипы сериализуемого класса должны быть сериализуемы. Если класс предок был несереализуемым, то этот суперкласс должен содержать доступный (public, protected) конструктор без параметров для инициализации полей.
Можно ли сериализовать final поле?
Поля с модификатором final сериализуются как и обычные. За одним исключением - их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.
Что будет при сериализации объекта у которого есть поле и оно не Serializable?
В таком случае код скомпилируется.
Но в рантайме при попытке сериализации , когда мы дойдем до этого поля и объекта, мы получим NotSerializableException.
Externalizable vs Serializable?
При записи Serializable класса весь контроль над сериализацией достается JVM. С помощью определения специальных методов можно кастомизировать его части.
Метод readObject при этом обычно начинается с вызова стандартной части сериализации  -ObjectInputStream.defaultReadObject().
Интерфейс Externalizable расширяет Serializable и добавляет методы записи и чтения writeExternal и readExternal. Входной и выходной потоки-аргументы в них представлены более абстрактно чем в специальных методах – интерфейсами ObjectInput и ObjectOutput.
Этот интерфейс позволяет реализовать полностью свой механизм сериализации, стандартно запишется только идентификатор класса. Никакой автоматической работы с классом-родителем также не предусмотрено. Методы readObject и writeObject игнорируются. Ключевое слово transient эффекта на Externalizable не имеет.
Externalizable объект в отличие от Serializable десерализуется не в обход конструктора, так что должен иметь конструктор без аргументов.
КЛОНИРОВАНИЕ
Клонирование объекта. Глубокое и поверхностное.
Клонирование объекта, метод clone() обеспечивает эту функциональность, необходимо реализовать интерфейс Cloneable.
Поверхностное клонирование применяется только с примитивными полями.
Глубокое с примитивными и ссылочными.
Поверхностного клонирования, создается новый объект, который имеет точную копию значений в исходном объекте. Метод clone () объекта обеспечивает поверхностное клонирование. В этом механизме клонирования объект копируется без содержащихся в нем объектов. Клон копирует только структуру верхнего уровня объекта, а не нижние уровни.
Глубокое клонирование, используют в тех случаях, когда в клонируемом классе есть изменяемые объекты, каждый изменяемый объект в графе объектов рекурсивно копируется.
Что такое клонирование? Как реализовано клонирование в Java?
Клонирование - создание чего-то нового на основе чего-то существующего.
В первую очередь необходимо реализовать интерфейс Cloneable. Если этого не сделать, при вызове метода clone() выбросится исключение CloneNotSupportedException.
Интерфейс Cloneable является маркерным, то есть не имеет ни одного метода.
Он показывает что объекты класса могут быть клонированы.
Метод clone() является protected, поэтому класс может клонировать только собственные объекты. Для того, чтобы клонировать другие объекты, метод clone() нужно расширить до public.
Пример клонирования: public User clone() { return (User) super.clone();}
Чем отличается копирование от клонирования?
Клонирование - создание чего-то нового на основе чего-то существующего.
Копирование - копирование из чего-то существующего во что-то другое (что также уже существует).
Можно ли клонировать String, массив String?
Класс String - immutable, неизменяемый.
Мы не можешь изменить существующий экземпляр String, только создать новый. А если мы полю одного объекта присвоишь новую ссылку, на клоне это никак не отразится - у него по-прежнему будет ссылка на исходный объект-строку.
Класс String не реализует этот интерфейс Cloneable и не переопределяет метод клонирования, поэтому возникает ошибка.
clone - это метод класса Object. Чтобы класс был "cloneable", он должен реализовать интерфейс marker Cloneable .
Когда метод clone вызывается для массива, он возвращает ссылку на новый массив, который содержит (или ссылается) те же элементы, что и исходный массив.



КЛАСС
В каких пакетах лежат классы-потоки?
Классы потоков ввода\вывода лежат в java.io; С JDK 7 добавлен более современный способ работы с потоками - Java NIO. Классы лежат в java.nio. Для работы с архивами используются классы из пакета java.util
Что вы знаете о классах-надстройках?
Классы-надстройки наделяют существующий поток дополнительными свойствами. Примеры классов: BufferedOutputStream, BufferedInputStream, BufferedWriter, BufferedReader - буферизируют поток и повышают производительность.
Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?
Класс DataInputStream представляет поток ввода и предназначен для записи данных примитивных типов, таких, как int, double и т.д. Для каждого примитивного типа определен свой метод для считывания:
boolean readBoolean(): считывает из потока булевое однобайтовое значение
byte readByte(): считывает из потока 1 байт
char readChar(): считывает из потока значение char
double readDouble(): считывает из потока 8-байтовое значение double
float readFloat(): считывает из потока 4-байтовое значение float
int readInt(): считывает из потока целочисленное значение int
long readLong(): считывает из потока значение long
short readShort(): считывает значение short
String readUTF(): считывает из потока строку в кодировке UTF-8
Класс DataInputStream позволяет читать элементарные данные из потока через интерфейс DataInput, который определяет методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в файле двоичных данных. Конструктор: DataInputStream(InputStream stream)
Методы: readDouble(), readBoolean(), readInt()
Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?
Для этого используются классы, позволяющие буферизировать поток: BufferedInputStream(InputStream in),
BufferedOutputStream(OutputStream out),
BufferedReader(Reader r),
BufferedWriter(Writer out).
Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?
1) OutputStreamWriter - мост между классом OutputStream и классом Writer.
Записанные в поток символы OutputStreamWriter преобразовывает в байты.
2) InputStreamReader - мост между классом InputStream и классом Reader. При помощи методов класса Reader прочитанные байты из потока InputStream преобразуются в символы.
Массив.можно преобразовать обратно в строку с помощью конструктора new String(byte[])
Метод getBytes(charsetName) класса String – преобразование char в byte
Какой класс предназначен для работы с элементами файловой системы (ЭФС)?
В отличие от большинства классов ввода/вывода, класс File работает не с потоками, а непосредственно с файлами. Данный класс позволяет получить информацию о файле: права доступа, время и дата создания, путь к каталогу. А также осуществлять навигацию по иерархиям подкаталогов. Класс java.io.File может представлять имя определённого файла, а также имена группы файлов, находящихся в каталоге. Если класс представляет каталог, то его метод list() возвращает массив строк с именами всех файлов.
Для создания объектов класса File можно использовать один из следующих конструкторов: File(File dir, String name) - указывается объект класса File (каталог) и имя файла
File(String path) - указывается путь к файлу без указания имени файла
File(String dirPath, String name) - указывается путь к файлу и имя файла
File(URI uri) - указывается объекта URI, описывающий файл
Какой символ является разделителем при указании пути к ЭФС?
Для различных систем символ разделителя различается. Вытащить его можно используя file.separator, а так же в статическом поле File.separator.
Для Windows это '\', и для unix его'/'
File.separator вытаскиваем разделитель системы и после может разделять путь separator
Что вы знаете об интерфейсе FilenameFilter?
Интерфейс FilenameFilter применяется для проверки попадает ли объект File под некоторое условие. Этот интерфейс содержит единственный метод boolean accept(File pathName). Этот метод необходимо переопределить и реализовать.
Какие классы позволяют архивировать объекты?
DeflaterOutputStream, InflaterInputStream,
ZipInputStream, ZipOutputStream,
GZIPInputStream, GZIPOutputStream.
Что делает метод read? Почему он возвращает int а не byte? Почему он не может возвращать byte?
Метод read - читает следующий байт из входящего потока. Когда метод ничего не может считать (конец потока), возвращается -1.
Почему он возвращает int а не byte - потому что нужен такой тип, который может вместить 1 байт, плюс одно служебное значение -1 (обозначающее конец потока).
Почему он не может возвращать byte - диапазон byte в Java лежит от -128 до 127, а возвращаемое значение метода read() лежит в диапазоне от 0 до 255.
Что вернет метод read(), если он считывает файл и ему встречается байт равный -1?
 255

